<!DOCTYPE html>
<html>
<head>
    <title>2048 Game</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            background-color: #faf8ef;
            color: #776e65;
        }
        #game-container {
            width: 400px;
            height: 400px;
            background-color: #bbada0;
            margin: 50px auto;
            border-radius: 6px;
            position: relative;
            overflow: hidden; /* Ensure tiles don't overflow during animation */
        }
        .grid-cell {
            width: 90px;
            height: 90px;
            background-color: rgba(238, 228, 218, 0.35);
            border-radius: 3px;
            position: absolute;
        }
        .tile {
            width: 90px;
            height: 90px;
            background-color: #eee4da;
            border-radius: 3px;
            position: absolute;
            font-size: 45px;
            font-weight: bold;
            color: #776e65;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: transform 0.2s ease-in-out, opacity 0.2s ease-in-out; /* Add transition for animation */
        }
        /* Tile background colors */
        .tile[data-value="2"] { background-color: #eee4da; color: #776e65; }
        .tile[data-value="4"] { background-color: #ede0c8; color: #776e65; }
        .tile[data-value="8"] { background-color: #f2b179; color: #f9f6f2; }
        .tile[data-value="16"] { background-color: #f59563; color: #f9f6f2; }
        .tile[data-value="32"] { background-color: #f67c5f; color: #f9f6f2; }
        .tile[data-value="64"] { background-color: #f65e3b; color: #f9f6f2; }
        .tile[data-value="128"] { background-color: #edcf72; color: #f9f6f2; }
        .tile[data-value="256"] { background-color: #edcc61; color: #f9f6f2; }
        .tile[data-value="512"] { background-color: #edc850; color: #f9f6f2; }
        .tile[data-value="1024"] { background-color: #edc53f; color: #f9f6f2; }
        .tile[data-value="2048"] { background-color: #edc22e; color: #f9f6f2; }
        /* Animation for new tiles */
        .tile.tile-new {
            animation: appear 0.2s ease-in-out;
        }
        @keyframes appear {
            0% {
                opacity: 0;
                transform: scale(0);
            }
            100% {
                opacity: 1;
                transform: scale(1);
            }
        }
        #score-container {
            margin-top: 20px;
            font-size: 24px;
            font-weight: bold;
        }
        #new-game-button {
            padding: 10px 20px;
            font-size: 18px;
            cursor: pointer;
            margin-top: 20px;
            background-color: #8f7a66;
            color: #f9f6f2;
            border: none;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <h1>2048</h1>
    <div id="score-container">Score: <span id="score">0</span></div>
    <div id="game-container"></div>
    <button id="new-game-button">New Game</button>

    <script>
        const gameContainer = document.getElementById('game-container');
        const scoreDisplay = document.getElementById('score');
        const newGameButton = document.getElementById('new-game-button');
        const gridSize = 4;
        const cellSize = 100; // Includes margin/padding implicitly
        const cellGap = 10;
        let board = [];
        let score = 0;
        let isMoving = false; // To prevent multiple moves while animation is running

        function initializeGame() {
            board = Array(gridSize).fill(0).map(() => Array(gridSize).fill(0));
            score = 0;
            scoreDisplay.textContent = score;
            renderBoard();
            addRandomTile();
            addRandomTile();
        }

        function createGridCells() {
            gameContainer.innerHTML = ''; // Clear existing tiles/cells
            for (let r = 0; r < gridSize; r++) {
                for (let c = 0; c < gridSize; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('grid-cell');
                    cell.style.left = `${c * (cellSize)}px`;
                    cell.style.top = `${r * (cellSize)}px`;
                    gameContainer.appendChild(cell);
                }
            }
        }

        function renderBoard() {
            // Remove existing tiles
            document.querySelectorAll('.tile').forEach(tile => tile.remove());

            for (let r = 0; r < gridSize; r++) {
                for (let c = 0; c < gridSize; c++) {
                    if (board[r][c] !== 0) {
                        const tile = document.createElement('div');
                        tile.classList.add('tile');
                        tile.dataset.value = board[r][c];
                        tile.textContent = board[r][c];
                        tile.style.left = `${c * (cellSize)}px`;
                        tile.style.top = `${r * (cellSize)}px`;
                        gameContainer.appendChild(tile);
                    }
                }
            }
        }

        function addRandomTile() {
            const availableCells = [];
            for (let r = 0; r < gridSize; r++) {
                for (let c = 0; c < gridSize; c++) {
                    if (board[r][c] === 0) {
                        availableCells.push({ r, c });
                    }
                }
            }

            if (availableCells.length > 0) {
                const randomCell = availableCells[Math.floor(Math.random() * availableCells.length)];
                const value = Math.random() < 0.9 ? 2 : 4;
                board[randomCell.r][randomCell.c] = value;

                // Create and animate the new tile
                const newTile = document.createElement('div');
                newTile.classList.add('tile', 'tile-new'); // Add tile-new class for animation
                newTile.dataset.value = value;
                newTile.textContent = value;
                newTile.style.left = `${randomCell.c * (cellSize)}px`;
                newTile.style.top = `${randomCell.r * (cellSize)}px`;
                gameContainer.appendChild(newTile);

                // Remove the 'tile-new' class after the animation
                newTile.addEventListener('animationend', () => {
                    newTile.classList.remove('tile-new');
                }, { once: true });
            }
        }

        function slideTiles(row) {
            let newRow = row.filter(val => val !== 0);
            let missing = gridSize - newRow.length;
            let zeros = Array(missing).fill(0);
            return zeros.concat(newRow);
        }

        function combineTiles(row) {
            for (let i = gridSize - 1; i > 0; i--) {
                if (row[i] !== 0 && row[i] === row[i - 1]) {
                    row[i] *= 2;
                    score += row[i];
                    row[i - 1] = 0;
                }
            }
            return row;
        }

        function move(direction) {
            if (isMoving) return; // Prevent moves during animation
            isMoving = true;

            let boardChanged = false;
            let oldBoard = JSON.parse(JSON.stringify(board)); // Deep copy for comparison

            // Handle tile movements and merging visually
            const tileElements = gameContainer.querySelectorAll('.tile');
            const tilePositions = new Map(); // Store current positions of tiles

            tileElements.forEach(tile => {
                const r = Math.round(parseInt(tile.style.top) / cellSize);
                const c = Math.round(parseInt(tile.style.left) / cellSize);
                tilePositions.set(`${r},${c}`, tile);
            });

            if (direction === 'up' || direction === 'down') {
                for (let c = 0; c < gridSize; c++) {
                    let column = [];
                    for (let r = 0; r < gridSize; r++) {
                        column.push(board[r][c]);
                    }
                    if (direction === 'up') {
                        column = slideTiles(column.filter(val => val !== 0)).filter(val => val !== 0);
                        column = combineTiles(column);
                        column = slideTiles(column); // Slide again after combining
                    } else { // down
                        column = slideTiles(column.filter(val => val !== 0)).filter(val => val !== 0).reverse();
                        column = combineTiles(column).reverse();
                        column = slideTiles(column.reverse()).reverse(); // Slide again after combining
                    }

                    // Pad with zeros
                    while (column.length < gridSize) {
                        if (direction === 'up') {
                            column.push(0);
                        } else {
                            column.unshift(0);
                        }
                    }

                    for (let r = 0; r < gridSize; r++) {
                        if (board[r][c] !== column[r]) {
                            boardChanged = true;
                        }
                        board[r][c] = column[r];
                    }
                }
            } else if (direction === 'left' || direction === 'right') {
                for (let r = 0; r < gridSize; r++) {
                    let row = board[r];
                    if (direction === 'left') {
                        row = slideTiles(row.filter(val => val !== 0));
                        row = combineTiles(row);
                        row = slideTiles(row); // Slide again after combining
                    } else { // right
                        row = slideTiles(row.filter(val => val !== 0)).reverse();
                        row = combineTiles(row).reverse();
                        row = slideTiles(row.reverse()).reverse(); // Slide again after combining
                    }

                    // Pad with zeros
                    while (row.length < gridSize) {
                        if (direction === 'left') {
                            row.push(0);
                        } else {
                            row.unshift(0);
                        }
                    }

                    if (board[r].some((val, i) => val !== row[i])) {
                        boardChanged = true;
                    }
                    board[r] = row;
                }
            }

            if (boardChanged) {
                // Animate existing tiles to their new positions
                tileElements.forEach(oldTile => {
                    const oldR = Math.round(parseInt(oldTile.style.top) / cellSize);
                    const oldC = Math.round(parseInt(oldTile.style.left) / cellSize);
                    let foundNewPos = false;

                    // Find the new position of this tile
                    for (let r = 0; r < gridSize; r++) {
                        for (let c = 0; c < gridSize; c++) {
                            if (oldBoard[oldR][oldC] === board[r][c] && !document.querySelector(`.tile[data-original-pos='${r},${c}']`)) {
                                oldTile.style.left = `${c * cellSize}px`;
                                oldTile.style.top = `${r * cellSize}px`;
                                oldTile.dataset.originalPos = `${r},${c}`; // Mark as moved
                                foundNewPos = true;
                                break;
                            }
                        }
                        if (foundNewPos) break;
                    }

                    // If a tile merged or moved off-board, fade it out
                    if (!foundNewPos || board[oldR][oldC] === 0) { // Condition to check for merged or disappeared tiles
                         oldTile.style.opacity = '0';
                    }
                });

                // Wait for animations to complete before updating board and adding new tile
                setTimeout(() => {
                    scoreDisplay.textContent = score;
                    renderBoard();
                    addRandomTile();
                    checkGameOver();
                    isMoving = false; // Release lock
                }, 200); // Match CSS transition duration
            } else {
                isMoving = false; // Release lock immediately if no move
            }
        }

        function checkGameOver() {
            // Check for empty cells
            for (let r = 0; r < gridSize; r++) {
                for (let c = 0; c < gridSize; c++) {
                    if (board[r][c] === 0) {
                        return; // Not game over if there's an empty cell
                    }
                }
            }

            // Check for possible moves
            for (let r = 0; r < gridSize; r++) {
                for (let c = 0; c < gridSize; c++) {
                    const currentValue = board[r][c];
                    // Check right
                    if (c < gridSize - 1 && currentValue === board[r][c + 1]) return;
                    // Check down
                    if (r < gridSize - 1 && currentValue === board[r + 1][c]) return;
                }
            }

            alert('Game Over! Your score: ' + score);
        }

        document.addEventListener('keydown', (e) => {
            if (isMoving) return; // Ignore input if an animation is in progress

            if (e.key === 'ArrowUp') {
                move('up');
            } else if (e.key === 'ArrowDown') {
                move('down');
            } else if (e.key === 'ArrowLeft') {
                move('left');
            } else if (e.key === 'ArrowRight') {
                move('right');
            }
        });

        newGameButton.addEventListener('click', initializeGame);

        createGridCells();
        initializeGame();
    </script>
</body>
</html>